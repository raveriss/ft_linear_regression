# 1) Param√©trage de la couverture (technique & CI)
* [ ] Activer **branch coverage** (pas seulement statement).
  * [ ] `.coveragerc`: `run: branch = True`
* [ ] Compter la couverture des **sous-processus/threads** (`concurrency = multiprocessing,thread`, `parallel = True`).
  * [ ] Exporter **COVERAGE_PROCESS_START=.coveragerc** en CI (et local).
  * [ ] Hook d‚Äôattache auto : fichier **sitecustomize.py** ou **.pth** qui fait import coverage; coverage.process_startup().
  * [ ] `run: concurrency = multiprocessing,thread` et `parallel = True`
  * [ ] Publier **coverage debug sys** en artefact (diagnostic chemins/interpr√©teur).
* [ ] **Contexts dynamiques** pour la pr√©cision du diff : `dynamic_context = test_function`.
* [ ] Interdire les tricheries (`# pragma: no cover`) et **justifier une par une**.
* [ ] Mesurer **tous les paquets pertinents** (pas d‚Äôexclusions abusives dans `omit=`).
* [ ] Agr√©ger correctement les runs parall√®les (`coverage combine`).
  * [ ] Combine **avant** `coverage xml`/upload et **apr√®s** tous les jobs CI.
* [ ] CI : **fail-under strict = 100**, **diff coverage = 100 %**, pas de flags Codecov qui masquent des dossiers.
  * [ ] Activer ‚Äúpatch must be 100%‚Äù c√¥t√© Codecov ; refuser les ‚Äúflags‚Äù qui excluent un r√©pertoire.
* [ ] **Report ergonomique** : `precision = 2`, `sort = Miss,Name`, `skip_empty = True`.
  * [ ] G√©n√©rer `coverage.xml` (pour Codecov) et HTML (audit manuel).
* [ ] **Publier coverage debug config et coverage debug data en artefacts (en plus de debug sys) pour diagnostiquer les fusions.
  * [ ] coverage debug config > coverage_debug_config.txt
  * [ ] coverage debug data > coverage_debug_data.txt
* [ ] **Nommer un fichier coverage par job pour √©viter les collisions de runs parall√®les :
  * [ ] COVERAGE_FILE=".coverage.${{ matrix.os }}-${{ matrix.python-version }}" (CI)
  * [ ] Variante locale : COVERAGE_FILE=".coverage.$(uname -s)-py$(python -c 'import sys;print(f\"{sys.version_info.major}.{sys.version_info.minor}\")')"

---

# 2) Sp√©cifique au sujet (conformit√© 42)

* [ ] **Deux programmes distincts** (`train.py`, `predict.py`).
* [ ] Hypoth√®se exacte : `estimatePrice(x) = Œ∏‚ÇÄ + Œ∏‚ÇÅ * x`.
* [ ] **Initialisation** : `Œ∏‚ÇÄ = 0`, `Œ∏‚ÇÅ = 0`.
* [ ] **Mise √† jour simultan√©e** via `tmpŒ∏‚ÇÄ`, `tmpŒ∏‚ÇÅ`.
* [ ] **Pas de lib magique** (`numpy.polyfit`, `sklearn.LinearRegression`).
* [ ] **Pr√©diction avant entra√Ænement = 0** pour tout km.
* [ ] **Persistance de Œ∏** robuste (ex. `theta.json` UTF‚Äë8) + comportement si fichier manquant/corrompu (message + exit code ‚â† 0).
* [ ] **CLI** pour `--alpha`, `--iters` (et `--seed` si n√©cessaire) afin d‚Äô√©viter les ‚Äúmagic numbers‚Äù.

---

# 3) Port√©e des tests (quoi couvrir)

* [ ] **Unitaires** : chaque fonction publique (cas nominal, limites, erreurs).
* [ ] **E2E** : `predict(0)=0 ‚Üí train ‚Üí predict(km du CSV) ‚âà prix`.
* [ ] **Branches conditionnelles** (`if/else`, `try/except/finally`).
* [ ] **Bool√©ens compos√©s** : tester (T,T), (T,F), (F,T), (F,F).
* [ ] **Erreurs I/O** : fichier manquant, CSV mal form√©, permissions, EOF stdin.
* [ ] **Num√©rique** : km n√©gatif, tr√®s grand, NaN, `,` d√©cimal, extrapolation hors plage.
* [ ] **Normalisation** (si ajout√©e) ‚Üí coh√©rence train/predict.
* [ ] **Locales & d√©cimales** : tests d√©di√©s fr_FR.UTF-8vsC (,et.) ; JSON de Œ∏ **toujours** en . (ind√©pendant de la locale).
* [ ] **Œ∏ persistance** : tests d√©di√©s (absent, JSON invalide, droits) ‚Üí messages + codes retour.
* [ ] ** Entrypoints/__main__ : couvrir l‚Äôex√©cution via python -m train / predict, y compris le bloc if __name__ == "__main__":.
* [ ] ** Early‚Äëstopping (si activ√©) : v√©rifier qu‚Äôon s‚Äôarr√™te quand ŒîJ < atol ou ‚ÄñŒîŒ∏‚Äñ < atol ; pas d‚Äôoscillation (J non croissant) ; journaliser le nbre d‚Äôit√©rations effectif.

---

# 4) Qualit√© des assertions

* [ ] ‚â•1 **assertion significative** par test (pas juste ‚Äú√ßa crashe pas‚Äù).
* [ ] V√©rifier valeurs **et effets de bord** (fichier Œ∏, exit code, logs).
* [ ] **Tol√©rances floats** (`rtol/atol`, jamais `==`).
* [ ] **Contrats n√©gatifs** : entr√©es invalides ‚Üí bonne exception/message.
* [ ] V√©rifier invariants : co√ªt ‚Üì, gradients ‚Üí 0.
* [ ] Comparer Œ∏ appris ‚âà solution OLS ferm√©e (oracle interne).
* [ ] Isolation par test : usage de tmp_path pour fichiers (theta.json) ‚Üí pas d‚Äô√©tat partag√©.
* [ ] Horloge fig√©e (ex. freezegun) si le code d√©pend du temps.
* [ ] Blocage r√©seau (pytest-socket) ‚Üí garantir ex√©cution offline.
* [ ] Nettoyage syst√©matique des fichiers temporaires.
* [ ] **Aide & erreurs CLI** : assertions explicites sur --help (exit=0, usage) et **messages d‚Äôerreur** (snapshot minimal, exit‚â†0).
* [ ] ** üß™ MAJ simultan√©e obligatoire** : un test √©choue si Œ∏‚ÇÄ, Œ∏‚ÇÅ sont mis √† jour sans temporaires (tmpŒ∏‚ÇÄ, tmpŒ∏‚ÇÅ).
Id√©e de test rapide : monkeypatcher qui force un ordre d‚Äô√©criture ‚Äúmauvais‚Äù ‚Üí v√©rifie que la somme d‚Äôerreurs augmente ou que l‚Äôinvariant ‚ÄúMAJ simultan√©e‚Äù est explicitement check√© (assert sur message/log).
---

# 5) Strat√©gies avanc√©es

* [ ] **Mutation testing** (`mutmut`, `cosmic-ray`) ‚Üí seuil ‚â• 90 %.
* [ ] **Budget temps** : scope cibl√© (core algo, I/O critique) + **timeout global** pour la CI stable.
* [ ] **Artefacts mutants** (logs + survivants) publi√©s en CI.
* [ ] **Property-based testing** (`hypothesis`).
* [ ] **Fuzz CLI** : encodages, CRLF, `,` vs `.`, Unicode.
* [ ] **Boundary analysis** (km=0, juste avant/apr√®s max).
* [ ] **Flaky guard** (`pytest-randomly`, `PYTHONHASHSEED`, seed RNG).
* [ ] Timeout par test (`pytest-timeout`).

---

# 6) Environnement & reproductibilit√©

* [ ] **Matrix CI** : ‚â•2 Python √ó ‚â•2 OS.
* [ ] **Verrouiller d√©pendances** (`poetry.lock`/`requirements.txt`).
* [ ] Tests offline (aucun acc√®s r√©seau).
* [ ] Tester locales (`fr_FR.UTF-8`, `C`).
* [ ] Paths relatifs/absolus, r√©pertoires read-only.
* [ ] **Combine cross‚Äëjobs** : artefacts `/.coverage.*` persist√©s puis `coverage combine` dans un job d‚Äôagr√©gation.
* [ ] **Tra√ßabilit√© run** : archiver METADATA.txt(Python/OS/locale/commit),coverage.xml, **HTML**, **logs mutation** (toujours, m√™me si job √©choue).
* [ ]  Chemins robustes : pr√©f√©rer pathlib.Path + resolve().relative_to(repo_root) ; refuser les hypoth√®ses sur le CWD.
---

# 7) Anti-patterns √† √©viter

* [ ] **Sur-mock** : pas du core algo.
* [ ] Tester comportement **public**, pas l‚Äôimpl√©mentation.
* [ ] **Tests cosm√©tiques** sans assert.
* [ ] Modules import√©s dynamiquement oubli√©s (dont `__main__`).

---

# 8) Garde-fous CI/Codecov

* [ ] PR bloqu√©es si couverture baisse.
* [ ] Refuser patch verts / global rouge ‚Üí diff = 100 %.
* [ ] **Seuil par fichier** : √©chouer si un fichier < 100 % (parser coverage json).
* [ ] Interdire `ignore:` non justifi√©s.
* [ ] Publier artefacts : `coverage.xml`, HTML, logs mutation.
* [ ] V√©rifier que Codecov ne filtre **aucun** dossier critique (pas de ‚Äúflags‚Äù excluants).
* [ ] **Codecov ‚Äúpinn√©‚Äù** : version fig√©e du binaire/codecovclien CI + **d√©sactiver l‚Äôauto‚Äëd√©tection des flags** danscodecov.yml.
* [ ] Upload inconditionnel (if: always()) des artefacts (coverage, HTML, logs mutation) pour diagnostiquer m√™me quand fail-under=100 stoppe les jobs.
* [ ] **Artefacts syst√©matiques** : coverage.xml, htmlcov/, logs mutation, METADATA.txtavecif: always().
* [ ] **Exporter coverage.json en plus de coverage.xml pour le contr√¥le ‚Äúseuil par fichier‚Äù.
* [ ] **Contr√¥le par fichier (script CI) : √©chouer si un fichier < 100‚ÄØ% (lecture de coverage.json).
* [ ] **üîê Codecov uploader v√©rifi√© : v√©rifier la signature/sha256 du binaire avant ex√©cution.
  * [ ] Pin de version (codecov-cli ou uploader autonome) + v√©rif sha256sum.
  * [ ] Refuser l‚Äôauto‚Äëd√©tection de flags (d√©j√† not√©) et pinner la version dans la CI.
* [ ] **üóÇÔ∏è COVERAGE_FILE par job** (rappel) : .coverage.${{ matrix.os }}-${{ matrix.python-version }} avant coverage combine.

* [ ] **üß∞ Artifacts diagnostics** : uploader coverage_debug_config.txt, coverage_debug_data.txt toujours (if: always()), en plus de coverage.xml, htmlcov/, logs mutation.
---

# 9) Sp√©cifique fichiers/CLI

* [ ] `--help` fonctionne, toutes options document√©es.
* [ ] **Tests d‚Äôinterface** : --help v√©rifi√© (contenu minimal), erreurs d‚Äôoptions malform√©es ‚Üí message clair + exit‚â†0.
* [ ] Entr√©es stdin/fichiers inexistants/dossiers g√©r√©s.
* [ ] UTF-8 partout, CRLF/LF tol√©r√©s.
* [ ] Codes de sortie : 0 succ√®s, ‚â†0 √©chec ‚Üí test√©s.
* [ ] üßæ **Snapshot CLI --help minimal (plugin de r√©gression) : valider usage/texte essentiel de --help et des erreurs d‚Äôoptions, avec snapshot compact (pour √©viter la fragilit√© vis‚Äë√†‚Äëvis des timestamps/paths).

---

# 10) Hygi√®ne & s√©curit√©

* [ ] Pas de **dead code** (`vulture`).
* [ ] Typage (`mypy`) + lint (`ruff`) en CI.
* [ ] Complexit√© (`radon/xenon`) contr√¥l√©e.
* [ ] Pas d‚Äô**injection shell** via input.
* [ ] Scripts ex√©cutables (`python3 train.py`).
* [ ] Pas de d√©pendances r√©seau.
* [ ] (Option) **pre-commit** pour format/lint/tests rapides en local.

---

# 11) Proc√©dure de validation finale

1. `pytest -q` ‚Üí tous les tests passent.
2. `coverage run -m pytest && coverage combine && coverage report --fail-under=100` (`branch=True`).
2bis. **V√©rif par‚Äëfichier** : coverage json ‚Üí **tous** les fichiers = 100 %
3. **Mutation testing** ‚â•90 %.
4. V√©rification visuelle HTML (tout vert).
5. V√©rification E2E : `predict(0)=0 ‚Üí train ‚Üí predict‚âàcsv`.
6. Rejouer en **matrix CI** (Python/OS).
7. V√©rifier artefacts mutants + couverture cross-jobs.
8. **Paquet d‚Äôartefacts** : coverage.xml, htmlcov/, logs mutation, METADATA.txt attach√©s au job final.

